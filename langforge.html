<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LinguaForge MVP - Language Evolution Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #fdbb2d;
            border-bottom: 2px solid #fdbb2d;
            padding-bottom: 5px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(45deg, #fdbb2d, #b21f1f);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        select, input {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background: rgba(255, 255, 255, 0.9);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #fdbb2d;
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .visualization {
            height: 300px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        .agent {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .communication-line {
            position: absolute;
            height: 2px;
            background: #fdbb2d;
            transform-origin: 0 0;
            transition: all 0.3s ease;
        }

        .log {
            height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.9em;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
        }

        .success { color: #4CAF50; }
        .failure { color: #f44336; }
        .innovation { color: #2196F3; }

        .vocabulary-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .word-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .language-stage {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            background: #fdbb2d;
            color: #000;
            font-size: 0.8em;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üó£Ô∏è LinguaForge MVP</h1>
            <div class="subtitle">Watch Language Emerge from Communication Pressure</div>
        </header>

        <div class="dashboard">
            <div class="panel">
                <h2>üåç Simulation Controls</h2>
                <div class="controls">
                    <button id="startBtn">‚ñ∂Ô∏è Start</button>
                    <button id="pauseBtn">‚è∏Ô∏è Pause</button>
                    <button id="resetBtn">üîÑ Reset</button>
                    <select id="simulationMode">
                        <option value="natural">üå± Natural Evolution</option>
                        <option value="island">üèùÔ∏è Island Isolation</option>
                        <option value="child">üßí Child Acquisition</option>
                    </select>
                    <input type="number" id="populationSize" value="20" min="5" max="50">
                </div>

                <div class="metrics-grid">
                    <div class="metric">
                        <div class="metric-value" id="generation">0</div>
                        <div class="metric-label">Generation</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="vocabularySize">0</div>
                        <div class="metric-label">Vocabulary</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="successRate">0%</div>
                        <div class="metric-label">Success Rate</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="languageStage">Gestural</div>
                        <div class="metric-label">Language Stage</div>
                    </div>
                </div>

                <div class="visualization" id="worldCanvas">
                    <!-- Agents and communication lines will be rendered here -->
                </div>
            </div>

            <div class="panel">
                <h2>üìä Language Evolution</h2>
                <div class="log" id="eventLog">
                    <div class="log-entry">Simulation ready. Click Start to begin!</div>
                </div>
                
                <h3>üìö Evolving Vocabulary</h3>
                <div class="vocabulary-list" id="vocabularyList">
                    <!-- Vocabulary will be listed here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        class LanguageAgent {
            constructor(id, x, y) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.lexicon = new Map(); // word -> meaning
                this.grammar = [];
                this.communicationHistory = [];
                this.successCount = 0;
                this.totalAttempts = 0;
                this.color = this.getRandomColor();
            }

            getRandomColor() {
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            getSuccessRate() {
                return this.totalAttempts === 0 ? 0 : (this.successCount / this.totalAttempts) * 100;
            }

            inventWord(meaning) {
                // Create a random "word" (combination of syllables)
                const syllables = ['ba', 'da', 'ka', 'la', 'ma', 'na', 'pa', 'ta', 'ga', 'sa'];
                const wordLength = Math.floor(Math.random() * 2) + 1; // 1-2 syllables
                let word = '';
                for (let i = 0; i < wordLength; i++) {
                    word += syllables[Math.floor(Math.random() * syllables.length)];
                }
                
                this.lexicon.set(word, meaning);
                return word;
            }

            getWordFor(meaning) {
                // Try to find existing word for meaning
                for (let [word, existingMeaning] of this.lexicon) {
                    if (existingMeaning === meaning) {
                        return word;
                    }
                }
                // Invent new word if none exists
                return this.inventWord(meaning);
            }

            interpret(word) {
                return this.lexicon.get(word);
            }

            communicate(partner, meaning) {
                const word = this.getWordFor(meaning);
                const understood = partner.interpret(word) === meaning;
                
                this.totalAttempts++;
                partner.totalAttempts++;
                
                if (understood) {
                    this.successCount++;
                    partner.successCount++;
                    // Reinforce successful communication
                    partner.lexicon.set(word, meaning);
                } else {
                    // Partner learns the word from context
                    partner.lexicon.set(word, meaning);
                }
                
                this.communicationHistory.push({
                    partner: partner.id,
                    word,
                    meaning,
                    success: understood,
                    timestamp: Date.now()
                });
                
                return { word, understood };
            }
        }

        class LinguaForgeSimulation {
            constructor() {
                this.agents = [];
                this.generation = 0;
                this.isRunning = false;
                this.concepts = ['food', 'water', 'danger', 'come', 'go', 'help', 'friend', 'enemy'];
                this.animationId = null;
                this.simulationSpeed = 1000; // ms between generations
                
                // DOM elements
                this.worldCanvas = document.getElementById('worldCanvas');
                this.eventLog = document.getElementById('eventLog');
                this.vocabularyList = document.getElementById('vocabularyList');
                this.generationElement = document.getElementById('generation');
                this.vocabularySizeElement = document.getElementById('vocabularySize');
                this.successRateElement = document.getElementById('successRate');
                this.languageStageElement = document.getElementById('languageStage');
                
                this.initializeEventListeners();
                this.resetSimulation();
            }

            initializeEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetSimulation());
            }

            resetSimulation() {
                this.pause();
                this.agents = [];
                this.generation = 0;
                this.updateMetrics();
                
                const populationSize = parseInt(document.getElementById('populationSize').value) || 20;
                this.initializeAgents(populationSize);
                this.renderWorld();
                this.logEvent('Simulation reset with ' + populationSize + ' agents');
            }

            initializeAgents(count) {
                this.agents = [];
                for (let i = 0; i < count; i++) {
                    const x = 50 + Math.random() * (this.worldCanvas.offsetWidth - 100);
                    const y = 50 + Math.random() * (this.worldCanvas.offsetHeight - 100);
                    this.agents.push(new LanguageAgent(i, x, y));
                }
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.logEvent('Simulation started');
                this.runGeneration();
            }

            pause() {
                this.isRunning = false;
                if (this.animationId) {
                    clearTimeout(this.animationId);
                    this.animationId = null;
                }
                this.logEvent('Simulation paused');
            }

            runGeneration() {
                if (!this.isRunning) return;

                // Perform communication attempts
                this.simulateCommunication();
                
                // Evolutionary steps
                this.evolveLanguage();
                
                this.generation++;
                this.updateMetrics();
                this.renderWorld();
                
                if (this.isRunning) {
                    this.animationId = setTimeout(() => this.runGeneration(), this.simulationSpeed);
                }
            }

            simulateCommunication() {
                // Clear previous communication lines
                document.querySelectorAll('.communication-line').forEach(el => el.remove());
                
                // Each agent communicates with 1-2 others
                this.agents.forEach(agent => {
                    const numCommunications = Math.floor(Math.random() * 2) + 1;
                    for (let i = 0; i < numCommunications; i++) {
                        const partner = this.getRandomPartner(agent);
                        const meaning = this.concepts[Math.floor(Math.random() * this.concepts.length)];
                        const result = agent.communicate(partner, meaning);
                        
                        // Visualize communication
                        this.visualizeCommunication(agent, partner, result.understood);
                        
                        // Log interesting events
                        if (!result.understood && Math.random() < 0.3) {
                            this.logEvent(`Agent ${agent.id} invented new word "${result.word}" for "${meaning}"`, 'innovation');
                        }
                    }
                });
            }

            getRandomPartner(agent) {
                let partner;
                do {
                    partner = this.agents[Math.floor(Math.random() * this.agents.length)];
                } while (partner === agent);
                return partner;
            }

            visualizeCommunication(agent1, agent2, success) {
                const line = document.createElement('div');
                line.className = 'communication-line';
                
                const dx = agent2.x - agent1.x;
                const dy = agent2.y - agent1.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                line.style.width = length + 'px';
                line.style.left = agent1.x + 'px';
                line.style.top = agent1.y + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                line.style.background = success ? '#4CAF50' : '#f44336';
                line.style.opacity = '0.7';
                
                this.worldCanvas.appendChild(line);
                
                // Remove line after animation
                setTimeout(() => {
                    if (line.parentNode) {
                        line.parentNode.removeChild(line);
                    }
                }, 800);
            }

            evolveLanguage() {
                // Language evolves based on success rates
                const avgSuccessRate = this.getAverageSuccessRate();
                
                // Agents with low success rates learn from successful ones
                this.agents.forEach(agent => {
                    if (agent.getSuccessRate() < avgSuccessRate) {
                        const successfulAgent = this.agents.reduce((best, current) => 
                            current.getSuccessRate() > best.getSuccessRate() ? current : best
                        );
                        
                        // Learn some words from successful agent
                        successfulAgent.lexicon.forEach((meaning, word) => {
                            if (Math.random() < 0.3) { // 30% chance to learn each word
                                agent.lexicon.set(word, meaning);
                            }
                        });
                    }
                });
            }

            getAverageSuccessRate() {
                const total = this.agents.reduce((sum, agent) => sum + agent.getSuccessRate(), 0);
                return total / this.agents.length;
            }

            getLanguageStage() {
                const vocabSize = this.getTotalVocabularySize();
                const successRate = this.getAverageSuccessRate();
                
                if (vocabSize < 5) return { stage: "Gestural", emoji: "üëÜ" };
                if (vocabSize < 15) return { stage: "Holistic", emoji: "üî§" };
                if (vocabSize < 30) return { stage: "Protolanguage", emoji: "üìù" };
                if (successRate < 70) return { stage: "Compositional", emoji: "üî†" };
                return { stage: "Recursive", emoji: "‚àû" };
            }

            getTotalVocabularySize() {
                const allWords = new Set();
                this.agents.forEach(agent => {
                    agent.lexicon.forEach((meaning, word) => {
                        allWords.add(word);
                    });
                });
                return allWords.size;
            }

            updateMetrics() {
                this.generationElement.textContent = this.generation;
                this.vocabularySizeElement.textContent = this.getTotalVocabularySize();
                this.successRateElement.textContent = Math.round(this.getAverageSuccessRate()) + '%';
                
                const languageStage = this.getLanguageStage();
                this.languageStageElement.textContent = languageStage.stage + ' ' + languageStage.emoji;
                
                this.updateVocabularyList();
            }

            updateVocabularyList() {
                // Count word frequencies across all agents
                const wordFrequencies = new Map();
                this.agents.forEach(agent => {
                    agent.lexicon.forEach((meaning, word) => {
                        wordFrequencies.set(word, (wordFrequencies.get(word) || 0) + 1);
                    });
                });
                
                // Sort by frequency
                const sortedWords = Array.from(wordFrequencies.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 10); // Show top 10 words
                
                this.vocabularyList.innerHTML = '';
                sortedWords.forEach(([word, frequency]) => {
                    const meaning = this.findCommonMeaning(word);
                    const item = document.createElement('div');
                    item.className = 'word-item';
                    item.innerHTML = `
                        <span>${word}</span>
                        <span>${meaning}</span>
                        <span style="color: #fdbb2d">${frequency} agents</span>
                    `;
                    this.vocabularyList.appendChild(item);
                });
            }

            findCommonMeaning(word) {
                // Find the most common meaning for a word across agents
                const meaningCounts = new Map();
                this.agents.forEach(agent => {
                    const meaning = agent.lexicon.get(word);
                    if (meaning) {
                        meaningCounts.set(meaning, (meaningCounts.get(meaning) || 0) + 1);
                    }
                });
                
                if (meaningCounts.size === 0) return '?';
                
                return Array.from(meaningCounts.entries())
                    .reduce((a, b) => a[1] > b[1] ? a : b)[0];
            }

            logEvent(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `Gen ${this.generation}: ${message}`;
                this.eventLog.appendChild(entry);
                this.eventLog.scrollTop = this.eventLog.scrollHeight;
                
                // Keep only last 20 entries
                while (this.eventLog.children.length > 20) {
                    this.eventLog.removeChild(this.eventLog.firstChild);
                }
            }

            renderWorld() {
                this.worldCanvas.innerHTML = '';
                
                this.agents.forEach(agent => {
                    const agentElement = document.createElement('div');
                    agentElement.className = 'agent';
                    agentElement.style.left = agent.x + 'px';
                    agentElement.style.top = agent.y + 'px';
                    agentElement.style.background = agent.color;
                    agentElement.style.boxShadow = `0 0 10px ${agent.color}`;
                    agentElement.textContent = agent.id;
                    agentElement.title = `Success: ${Math.round(agent.getSuccessRate())}%`;
                    
                    this.worldCanvas.appendChild(agentElement);
                });
            }
        }

        // Initialize the simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.simulation = new LinguaForgeSimulation();
        });
    </script>
</body>
</html>
